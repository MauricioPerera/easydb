/**
 * MongoDB Adapter for EasyDB
 *
 * Stores data as native MongoDB documents — no JSON serialization needed.
 * MongoDB's document model maps 1:1 to EasyDB's JSON records.
 *
 * Best for:
 * - Document-oriented data, flexible schemas
 * - Native secondary indexes and unique constraints
 * - Shared state across services
 *
 * Limitations:
 * - Snapshot/rollback transactions (no replica set required)
 * - All queries fetch and sort in JS (same as Redis adapter)
 *
 * Usage:
 *   import EasyDB from '@rckflr/easydb';
 *   import { MongoAdapter } from '@rckflr/easydb/adapters/mongo';
 *   import { MongoClient } from 'mongodb';
 *
 *   const client = new MongoClient(process.env.MONGO_URL);
 *   await client.connect();
 *   const db = await EasyDB.open('app', {
 *     adapter: new MongoAdapter(client.db('mydb')),
 *     schema(s) {
 *       s.createStore('users', { key: 'id' });
 *       s.createStore('tasks', { key: 'id', autoIncrement: true });
 *     }
 *   });
 */

// ── MongoConnection ────────────────────────────────────────

class MongoConnection {
  constructor(name, db, stores, version, prefix) {
    this._name = name;
    this._db = db;
    this._stores = stores;
    this._version = version;
    this._prefix = prefix;
  }

  get name() { return this._name; }
  get version() { return this._version; }
  get storeNames() { return Array.from(this._stores.keys()); }

  hasStore(name) { return this._stores.has(name); }

  getKeyPath(storeName) {
    const meta = this._stores.get(storeName);
    return meta ? meta.keyPath : null;
  }

  close() { /* no-op — caller manages MongoDB connection */ }

  // ── Collection helpers ──

  _col(storeName) { return this._db.collection(`${this._prefix}${storeName}`); }
  _metaCol() { return this._db.collection(`${this._prefix}_easydb_meta`); }

  _meta(storeName) {
    const meta = this._stores.get(storeName);
    if (!meta) throw new Error(`EasyDB: Store "${storeName}" not found`);
    return meta;
  }

  // ── Read ops ──

  async get(storeName, key) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);
    const doc = await col.findOne({ [meta.keyPath]: key });
    if (!doc) return undefined;
    const { _id, ...rest } = doc;
    return meta.keyPath === '_id' ? doc : rest;
  }

  async getAll(storeName, opts = {}) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);

    let filter = {};
    if (opts.range) {
      const field = opts.index || meta.keyPath;
      filter[field] = this._rangeToQuery(opts.range);
    }

    const projection = meta.keyPath === '_id' ? {} : { _id: 0 };
    let cursor = col.find(filter, { projection });

    const sortField = opts.index || meta.keyPath;
    cursor = cursor.sort({ [sortField]: 1 });

    if (opts.limit != null) cursor = cursor.limit(opts.limit);

    return cursor.toArray();
  }

  async count(storeName, opts = {}) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);

    if (!opts.range) {
      return col.countDocuments({});
    }

    const field = opts.index || meta.keyPath;
    const filter = { [field]: this._rangeToQuery(opts.range) };
    return col.countDocuments(filter);
  }

  async getMany(storeName, keys) {
    const meta = this._meta(storeName);
    if (!keys.length) return [];

    const results = [];
    for (const key of keys) {
      results.push(await this.get(storeName, key));
    }
    return results;
  }

  // ── Write ops ──

  async put(storeName, value) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);
    let key;
    let autoGenerated = false;

    if (meta.keyPath) {
      key = value[meta.keyPath];
      if (key == null && meta.autoIncrement) {
        key = await this._nextKey(storeName);
        value = { ...value, [meta.keyPath]: key };
        autoGenerated = true;
      }
    } else if (meta.autoIncrement) {
      key = await this._nextKey(storeName);
      autoGenerated = true;
    } else {
      throw new Error('EasyDB: Cannot put without keyPath or autoIncrement');
    }

    // Advance counter if explicit numeric key >= current
    if (meta.autoIncrement && !autoGenerated && typeof key === 'number') {
      const metaCol = this._metaCol();
      const counterDoc = await metaCol.findOne({ _id: `counter:${storeName}` });
      const currentSeq = counterDoc ? counterDoc.seq : 0;
      if (key >= currentSeq) {
        await metaCol.updateOne(
          { _id: `counter:${storeName}` },
          { $set: { seq: key + 1 } },
          { upsert: true }
        );
      }
    }

    // Check unique index constraints
    if (meta.indexes.length > 0) {
      const uniqueIndexes = meta.indexes.filter(i => i.unique);
      for (const idx of uniqueIndexes) {
        if (value[idx.name] != null) {
          const existing = await col.findOne({ [idx.name]: value[idx.name] });
          if (existing) {
            const existingKey = existing[meta.keyPath];
            if (existingKey !== key) {
              throw new DOMException(
                'Key already exists in the object store.',
                'ConstraintError'
              );
            }
          }
        }
      }
    }

    await col.replaceOne(
      { [meta.keyPath]: key },
      value,
      { upsert: true }
    );
    return key;
  }

  async delete(storeName, key) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);
    await col.deleteOne({ [meta.keyPath]: key });
  }

  async clear(storeName) {
    this._meta(storeName);
    const col = this._col(storeName);
    await col.deleteMany({});
  }

  async putMany(storeName, items) {
    const keys = [];
    for (const item of items) {
      keys.push(await this.put(storeName, item));
    }
    return keys;
  }

  // ── Cursor (async generator) ──

  async *cursor(storeName, opts = {}) {
    const meta = this._meta(storeName);
    const col = this._col(storeName);

    let filter = {};
    if (opts.range) {
      const field = opts.index || meta.keyPath;
      filter[field] = this._rangeToQuery(opts.range);
    }

    const sortField = opts.index || meta.keyPath;
    const sortDir = opts.direction === 'prev' ? -1 : 1;
    const projection = meta.keyPath === '_id' ? {} : { _id: 0 };

    const cursor = col.find(filter, { projection }).sort({ [sortField]: sortDir });

    for await (const doc of cursor) {
      yield doc;
    }
  }

  // ── Multi-store transaction (snapshot/rollback) ──

  async transaction(storeNames, fn) {
    // Take snapshots
    const snapshots = new Map();
    for (const name of storeNames) {
      const meta = this._meta(name);
      const projection = meta.keyPath === '_id' ? {} : { _id: 0 };
      const docs = await this._col(name).find({}, { projection }).toArray();
      snapshots.set(name, docs);
    }

    const self = this;
    const proxy = new Proxy({}, {
      get(_, storeName) {
        return {
          get: (key) => self.get(storeName, key),
          put: (val) => self.put(storeName, val),
          delete: (key) => self.delete(storeName, key),
          getAll: () => self.getAll(storeName),
          count: () => self.count(storeName),
        };
      }
    });

    try {
      await fn(proxy);
    } catch (err) {
      // Rollback: restore snapshots
      for (const [name, snapshot] of snapshots) {
        const col = this._col(name);
        await col.deleteMany({});
        if (snapshot.length > 0) {
          await col.insertMany(snapshot);
        }
      }
      throw err;
    }
  }

  // ── Internal helpers ──

  async _nextKey(storeName) {
    const metaCol = this._metaCol();
    const result = await metaCol.findOneAndUpdate(
      { _id: `counter:${storeName}` },
      { $inc: { seq: 1 } },
      { upsert: true, returnDocument: 'after' }
    );
    return result.seq;
  }

  _rangeToQuery(range) {
    const q = {};
    if ('lower' in range && 'upper' in range && range.lower === range.upper && !range.lowerOpen && !range.upperOpen) {
      return range.lower; // exact match
    }
    if ('lower' in range) {
      q[range.lowerOpen ? '$gt' : '$gte'] = range.lower;
    }
    if ('upper' in range) {
      q[range.upperOpen ? '$lt' : '$lte'] = range.upper;
    }
    return q;
  }
}

// ── MongoAdapter ──────────────────────────────────────────

export class MongoAdapter {
  constructor(dbOrClient, opts = {}) {
    // Duck-type detection: Db has .collection(), MongoClient has .db()
    if (typeof dbOrClient.collection === 'function') {
      this._db = dbOrClient;
    } else if (typeof dbOrClient.db === 'function') {
      this._db = dbOrClient.db(opts.dbName);
    } else {
      throw new Error('EasyDB: MongoAdapter requires a mongodb Db instance or MongoClient');
    }
    this._prefix = opts.prefix ?? '';
  }

  async open(name, options = {}) {
    const version = options.version ?? 1;
    const prefix = this._prefix;
    const metaCol = this._db.collection(`${prefix}_easydb_meta`);

    const metaDoc = await metaCol.findOne({ _id: `db:${name}` });
    const currentVersion = metaDoc ? metaDoc.version : 0;
    const stores = new Map();

    if (currentVersion < version && options.schema) {
      const storeDefs = [];

      options.schema({
        createStore(storeName, opts = {}) {
          storeDefs.push({ storeName, opts });
        },
        getStore() { return null; }
      }, currentVersion);

      // Carry forward existing store meta
      const existingStores = metaDoc ? metaDoc.stores : {};
      for (const [storeName, meta] of Object.entries(existingStores)) {
        stores.set(storeName, meta);
      }

      for (const { storeName, opts } of storeDefs) {
        const indexes = [];
        if (opts.indexes) {
          for (const idx of opts.indexes) {
            const n = typeof idx === 'string' ? idx : idx.name;
            const unique = typeof idx === 'string' ? false : (idx.unique || false);
            indexes.push({ name: n, unique });
          }
        }

        const meta = {
          keyPath: opts.key || null,
          autoIncrement: opts.autoIncrement || false,
          indexes,
        };

        stores.set(storeName, meta);

        // Create MongoDB indexes on the collection
        const col = this._db.collection(`${prefix}${storeName}`);
        if (meta.keyPath && meta.keyPath !== '_id') {
          await col.createIndex({ [meta.keyPath]: 1 }, { unique: true, sparse: true });
        }
        for (const idx of indexes) {
          await col.createIndex(
            { [idx.name]: 1 },
            { unique: idx.unique, sparse: true }
          );
        }
      }

      // Save metadata
      const storesObj = {};
      for (const [n, m] of stores) storesObj[n] = m;
      await metaCol.replaceOne(
        { _id: `db:${name}` },
        { _id: `db:${name}`, version, stores: storesObj },
        { upsert: true }
      );
    }

    // Load existing stores if we didn't just migrate
    if (stores.size === 0 && metaDoc) {
      for (const [storeName, meta] of Object.entries(metaDoc.stores)) {
        stores.set(storeName, meta);
      }
    }

    return new MongoConnection(name, this._db, stores, version, prefix);
  }

  async destroy(name) {
    const prefix = this._prefix;
    const metaCol = this._db.collection(`${prefix}_easydb_meta`);

    const metaDoc = await metaCol.findOne({ _id: `db:${name}` });
    if (metaDoc) {
      for (const storeName of Object.keys(metaDoc.stores)) {
        await this._db.collection(`${prefix}${storeName}`).drop().catch(() => {});
      }
      // Clean up counters
      for (const storeName of Object.keys(metaDoc.stores)) {
        await metaCol.deleteOne({ _id: `counter:${storeName}` });
      }
    }

    await metaCol.deleteOne({ _id: `db:${name}` });
  }
}
